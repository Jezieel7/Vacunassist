{"ast":null,"code":"class OldSelector {\n  constructor(selector, prefix) {\n    this.prefix = prefix;\n    this.prefixed = selector.prefixed(this.prefix);\n    this.regexp = selector.regexp(this.prefix);\n    this.prefixeds = selector.possible().map(x => [selector.prefixed(x), selector.regexp(x)]);\n    this.unprefixed = selector.name;\n    this.nameRegexp = selector.regexp();\n  }\n  /**\n   * Is rule a hack without unprefixed version bottom\n   */\n\n\n  isHack(rule) {\n    let index = rule.parent.index(rule) + 1;\n    let rules = rule.parent.nodes;\n\n    while (index < rules.length) {\n      let before = rules[index].selector;\n\n      if (!before) {\n        return true;\n      }\n\n      if (before.includes(this.unprefixed) && before.match(this.nameRegexp)) {\n        return false;\n      }\n\n      let some = false;\n\n      for (let [string, regexp] of this.prefixeds) {\n        if (before.includes(string) && before.match(regexp)) {\n          some = true;\n          break;\n        }\n      }\n\n      if (!some) {\n        return true;\n      }\n\n      index += 1;\n    }\n\n    return true;\n  }\n  /**\n   * Does rule contain an unnecessary prefixed selector\n   */\n\n\n  check(rule) {\n    if (!rule.selector.includes(this.prefixed)) {\n      return false;\n    }\n\n    if (!rule.selector.match(this.regexp)) {\n      return false;\n    }\n\n    if (this.isHack(rule)) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nmodule.exports = OldSelector;","map":{"version":3,"names":["OldSelector","constructor","selector","prefix","prefixed","regexp","prefixeds","possible","map","x","unprefixed","name","nameRegexp","isHack","rule","index","parent","rules","nodes","length","before","includes","match","some","string","check","module","exports"],"sources":["C:/Users/PC/Desktop/programaciÃ³n/VacunAssistIS2/Vacunassist/node_modules/autoprefixer/lib/old-selector.js"],"sourcesContent":["class OldSelector {\n  constructor(selector, prefix) {\n    this.prefix = prefix\n    this.prefixed = selector.prefixed(this.prefix)\n    this.regexp = selector.regexp(this.prefix)\n\n    this.prefixeds = selector\n      .possible()\n      .map(x => [selector.prefixed(x), selector.regexp(x)])\n\n    this.unprefixed = selector.name\n    this.nameRegexp = selector.regexp()\n  }\n\n  /**\n   * Is rule a hack without unprefixed version bottom\n   */\n  isHack(rule) {\n    let index = rule.parent.index(rule) + 1\n    let rules = rule.parent.nodes\n\n    while (index < rules.length) {\n      let before = rules[index].selector\n      if (!before) {\n        return true\n      }\n\n      if (before.includes(this.unprefixed) && before.match(this.nameRegexp)) {\n        return false\n      }\n\n      let some = false\n      for (let [string, regexp] of this.prefixeds) {\n        if (before.includes(string) && before.match(regexp)) {\n          some = true\n          break\n        }\n      }\n\n      if (!some) {\n        return true\n      }\n\n      index += 1\n    }\n\n    return true\n  }\n\n  /**\n   * Does rule contain an unnecessary prefixed selector\n   */\n  check(rule) {\n    if (!rule.selector.includes(this.prefixed)) {\n      return false\n    }\n    if (!rule.selector.match(this.regexp)) {\n      return false\n    }\n    if (this.isHack(rule)) {\n      return false\n    }\n    return true\n  }\n}\n\nmodule.exports = OldSelector\n"],"mappings":"AAAA,MAAMA,WAAN,CAAkB;EAChBC,WAAW,CAACC,QAAD,EAAWC,MAAX,EAAmB;IAC5B,KAAKA,MAAL,GAAcA,MAAd;IACA,KAAKC,QAAL,GAAgBF,QAAQ,CAACE,QAAT,CAAkB,KAAKD,MAAvB,CAAhB;IACA,KAAKE,MAAL,GAAcH,QAAQ,CAACG,MAAT,CAAgB,KAAKF,MAArB,CAAd;IAEA,KAAKG,SAAL,GAAiBJ,QAAQ,CACtBK,QADc,GAEdC,GAFc,CAEVC,CAAC,IAAI,CAACP,QAAQ,CAACE,QAAT,CAAkBK,CAAlB,CAAD,EAAuBP,QAAQ,CAACG,MAAT,CAAgBI,CAAhB,CAAvB,CAFK,CAAjB;IAIA,KAAKC,UAAL,GAAkBR,QAAQ,CAACS,IAA3B;IACA,KAAKC,UAAL,GAAkBV,QAAQ,CAACG,MAAT,EAAlB;EACD;EAED;AACF;AACA;;;EACEQ,MAAM,CAACC,IAAD,EAAO;IACX,IAAIC,KAAK,GAAGD,IAAI,CAACE,MAAL,CAAYD,KAAZ,CAAkBD,IAAlB,IAA0B,CAAtC;IACA,IAAIG,KAAK,GAAGH,IAAI,CAACE,MAAL,CAAYE,KAAxB;;IAEA,OAAOH,KAAK,GAAGE,KAAK,CAACE,MAArB,EAA6B;MAC3B,IAAIC,MAAM,GAAGH,KAAK,CAACF,KAAD,CAAL,CAAab,QAA1B;;MACA,IAAI,CAACkB,MAAL,EAAa;QACX,OAAO,IAAP;MACD;;MAED,IAAIA,MAAM,CAACC,QAAP,CAAgB,KAAKX,UAArB,KAAoCU,MAAM,CAACE,KAAP,CAAa,KAAKV,UAAlB,CAAxC,EAAuE;QACrE,OAAO,KAAP;MACD;;MAED,IAAIW,IAAI,GAAG,KAAX;;MACA,KAAK,IAAI,CAACC,MAAD,EAASnB,MAAT,CAAT,IAA6B,KAAKC,SAAlC,EAA6C;QAC3C,IAAIc,MAAM,CAACC,QAAP,CAAgBG,MAAhB,KAA2BJ,MAAM,CAACE,KAAP,CAAajB,MAAb,CAA/B,EAAqD;UACnDkB,IAAI,GAAG,IAAP;UACA;QACD;MACF;;MAED,IAAI,CAACA,IAAL,EAAW;QACT,OAAO,IAAP;MACD;;MAEDR,KAAK,IAAI,CAAT;IACD;;IAED,OAAO,IAAP;EACD;EAED;AACF;AACA;;;EACEU,KAAK,CAACX,IAAD,EAAO;IACV,IAAI,CAACA,IAAI,CAACZ,QAAL,CAAcmB,QAAd,CAAuB,KAAKjB,QAA5B,CAAL,EAA4C;MAC1C,OAAO,KAAP;IACD;;IACD,IAAI,CAACU,IAAI,CAACZ,QAAL,CAAcoB,KAAd,CAAoB,KAAKjB,MAAzB,CAAL,EAAuC;MACrC,OAAO,KAAP;IACD;;IACD,IAAI,KAAKQ,MAAL,CAAYC,IAAZ,CAAJ,EAAuB;MACrB,OAAO,KAAP;IACD;;IACD,OAAO,IAAP;EACD;;AA/De;;AAkElBY,MAAM,CAACC,OAAP,GAAiB3B,WAAjB"},"metadata":{},"sourceType":"script"}