{"ast":null,"code":"let parser = require('postcss-value-parser');\n\nlet range = require('normalize-range');\n\nlet OldValue = require('../old-value');\n\nlet Value = require('../value');\n\nlet utils = require('../utils');\n\nlet IS_DIRECTION = /top|left|right|bottom/gi;\n\nclass Gradient extends Value {\n  /**\n   * Change degrees for webkit prefix\n   */\n  replace(string, prefix) {\n    let ast = parser(string);\n\n    for (let node of ast.nodes) {\n      if (node.type === 'function' && node.value === this.name) {\n        node.nodes = this.newDirection(node.nodes);\n        node.nodes = this.normalize(node.nodes);\n\n        if (prefix === '-webkit- old') {\n          let changes = this.oldWebkit(node);\n\n          if (!changes) {\n            return false;\n          }\n        } else {\n          node.nodes = this.convertDirection(node.nodes);\n          node.value = prefix + node.value;\n        }\n      }\n    }\n\n    return ast.toString();\n  }\n  /**\n   * Replace first token\n   */\n\n\n  replaceFirst(params) {\n    for (var _len = arguments.length, words = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      words[_key - 1] = arguments[_key];\n    }\n\n    let prefix = words.map(i => {\n      if (i === ' ') {\n        return {\n          type: 'space',\n          value: i\n        };\n      }\n\n      return {\n        type: 'word',\n        value: i\n      };\n    });\n    return prefix.concat(params.slice(1));\n  }\n  /**\n   * Convert angle unit to deg\n   */\n\n\n  normalizeUnit(str, full) {\n    let num = parseFloat(str);\n    let deg = num / full * 360;\n    return `${deg}deg`;\n  }\n  /**\n   * Normalize angle\n   */\n\n\n  normalize(nodes) {\n    if (!nodes[0]) return nodes;\n\n    if (/-?\\d+(.\\d+)?grad/.test(nodes[0].value)) {\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 400);\n    } else if (/-?\\d+(.\\d+)?rad/.test(nodes[0].value)) {\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 2 * Math.PI);\n    } else if (/-?\\d+(.\\d+)?turn/.test(nodes[0].value)) {\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 1);\n    } else if (nodes[0].value.includes('deg')) {\n      let num = parseFloat(nodes[0].value);\n      num = range.wrap(0, 360, num);\n      nodes[0].value = `${num}deg`;\n    }\n\n    if (nodes[0].value === '0deg') {\n      nodes = this.replaceFirst(nodes, 'to', ' ', 'top');\n    } else if (nodes[0].value === '90deg') {\n      nodes = this.replaceFirst(nodes, 'to', ' ', 'right');\n    } else if (nodes[0].value === '180deg') {\n      nodes = this.replaceFirst(nodes, 'to', ' ', 'bottom');\n    } else if (nodes[0].value === '270deg') {\n      nodes = this.replaceFirst(nodes, 'to', ' ', 'left');\n    }\n\n    return nodes;\n  }\n  /**\n   * Replace old direction to new\n   */\n\n\n  newDirection(params) {\n    if (params[0].value === 'to') {\n      return params;\n    }\n\n    IS_DIRECTION.lastIndex = 0; // reset search index of global regexp\n\n    if (!IS_DIRECTION.test(params[0].value)) {\n      return params;\n    }\n\n    params.unshift({\n      type: 'word',\n      value: 'to'\n    }, {\n      type: 'space',\n      value: ' '\n    });\n\n    for (let i = 2; i < params.length; i++) {\n      if (params[i].type === 'div') {\n        break;\n      }\n\n      if (params[i].type === 'word') {\n        params[i].value = this.revertDirection(params[i].value);\n      }\n    }\n\n    return params;\n  }\n  /**\n   * Look for at word\n   */\n\n\n  isRadial(params) {\n    let state = 'before';\n\n    for (let param of params) {\n      if (state === 'before' && param.type === 'space') {\n        state = 'at';\n      } else if (state === 'at' && param.value === 'at') {\n        state = 'after';\n      } else if (state === 'after' && param.type === 'space') {\n        return true;\n      } else if (param.type === 'div') {\n        break;\n      } else {\n        state = 'before';\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Change new direction to old\n   */\n\n\n  convertDirection(params) {\n    if (params.length > 0) {\n      if (params[0].value === 'to') {\n        this.fixDirection(params);\n      } else if (params[0].value.includes('deg')) {\n        this.fixAngle(params);\n      } else if (this.isRadial(params)) {\n        this.fixRadial(params);\n      }\n    }\n\n    return params;\n  }\n  /**\n   * Replace `to top left` to `bottom right`\n   */\n\n\n  fixDirection(params) {\n    params.splice(0, 2);\n\n    for (let param of params) {\n      if (param.type === 'div') {\n        break;\n      }\n\n      if (param.type === 'word') {\n        param.value = this.revertDirection(param.value);\n      }\n    }\n  }\n  /**\n   * Add 90 degrees\n   */\n\n\n  fixAngle(params) {\n    let first = params[0].value;\n    first = parseFloat(first);\n    first = Math.abs(450 - first) % 360;\n    first = this.roundFloat(first, 3);\n    params[0].value = `${first}deg`;\n  }\n  /**\n   * Fix radial direction syntax\n   */\n\n\n  fixRadial(params) {\n    let first = [];\n    let second = [];\n    let a, b, c, i, next;\n\n    for (i = 0; i < params.length - 2; i++) {\n      a = params[i];\n      b = params[i + 1];\n      c = params[i + 2];\n\n      if (a.type === 'space' && b.value === 'at' && c.type === 'space') {\n        next = i + 3;\n        break;\n      } else {\n        first.push(a);\n      }\n    }\n\n    let div;\n\n    for (i = next; i < params.length; i++) {\n      if (params[i].type === 'div') {\n        div = params[i];\n        break;\n      } else {\n        second.push(params[i]);\n      }\n    }\n\n    params.splice(0, i, ...second, div, ...first);\n  }\n\n  revertDirection(word) {\n    return Gradient.directions[word.toLowerCase()] || word;\n  }\n  /**\n   * Round float and save digits under dot\n   */\n\n\n  roundFloat(float, digits) {\n    return parseFloat(float.toFixed(digits));\n  }\n  /**\n   * Convert to old webkit syntax\n   */\n\n\n  oldWebkit(node) {\n    let {\n      nodes\n    } = node;\n    let string = parser.stringify(node.nodes);\n\n    if (this.name !== 'linear-gradient') {\n      return false;\n    }\n\n    if (nodes[0] && nodes[0].value.includes('deg')) {\n      return false;\n    }\n\n    if (string.includes('px') || string.includes('-corner') || string.includes('-side')) {\n      return false;\n    }\n\n    let params = [[]];\n\n    for (let i of nodes) {\n      params[params.length - 1].push(i);\n\n      if (i.type === 'div' && i.value === ',') {\n        params.push([]);\n      }\n    }\n\n    this.oldDirection(params);\n    this.colorStops(params);\n    node.nodes = [];\n\n    for (let param of params) {\n      node.nodes = node.nodes.concat(param);\n    }\n\n    node.nodes.unshift({\n      type: 'word',\n      value: 'linear'\n    }, this.cloneDiv(node.nodes));\n    node.value = '-webkit-gradient';\n    return true;\n  }\n  /**\n   * Change direction syntax to old webkit\n   */\n\n\n  oldDirection(params) {\n    let div = this.cloneDiv(params[0]);\n\n    if (params[0][0].value !== 'to') {\n      return params.unshift([{\n        type: 'word',\n        value: Gradient.oldDirections.bottom\n      }, div]);\n    } else {\n      let words = [];\n\n      for (let node of params[0].slice(2)) {\n        if (node.type === 'word') {\n          words.push(node.value.toLowerCase());\n        }\n      }\n\n      words = words.join(' ');\n      let old = Gradient.oldDirections[words] || words;\n      params[0] = [{\n        type: 'word',\n        value: old\n      }, div];\n      return params[0];\n    }\n  }\n  /**\n   * Get div token from exists parameters\n   */\n\n\n  cloneDiv(params) {\n    for (let i of params) {\n      if (i.type === 'div' && i.value === ',') {\n        return i;\n      }\n    }\n\n    return {\n      type: 'div',\n      value: ',',\n      after: ' '\n    };\n  }\n  /**\n   * Change colors syntax to old webkit\n   */\n\n\n  colorStops(params) {\n    let result = [];\n\n    for (let i = 0; i < params.length; i++) {\n      let pos;\n      let param = params[i];\n      let item;\n\n      if (i === 0) {\n        continue;\n      }\n\n      let color = parser.stringify(param[0]);\n\n      if (param[1] && param[1].type === 'word') {\n        pos = param[1].value;\n      } else if (param[2] && param[2].type === 'word') {\n        pos = param[2].value;\n      }\n\n      let stop;\n\n      if (i === 1 && (!pos || pos === '0%')) {\n        stop = `from(${color})`;\n      } else if (i === params.length - 1 && (!pos || pos === '100%')) {\n        stop = `to(${color})`;\n      } else if (pos) {\n        stop = `color-stop(${pos}, ${color})`;\n      } else {\n        stop = `color-stop(${color})`;\n      }\n\n      let div = param[param.length - 1];\n      params[i] = [{\n        type: 'word',\n        value: stop\n      }];\n\n      if (div.type === 'div' && div.value === ',') {\n        item = params[i].push(div);\n      }\n\n      result.push(item);\n    }\n\n    return result;\n  }\n  /**\n   * Remove old WebKit gradient too\n   */\n\n\n  old(prefix) {\n    if (prefix === '-webkit-') {\n      let type = this.name === 'linear-gradient' ? 'linear' : 'radial';\n      let string = '-gradient';\n      let regexp = utils.regexp(`-webkit-(${type}-gradient|gradient\\\\(\\\\s*${type})`, false);\n      return new OldValue(this.name, prefix + this.name, string, regexp);\n    } else {\n      return super.old(prefix);\n    }\n  }\n  /**\n   * Do not add non-webkit prefixes for list-style and object\n   */\n\n\n  add(decl, prefix) {\n    let p = decl.prop;\n\n    if (p.includes('mask')) {\n      if (prefix === '-webkit-' || prefix === '-webkit- old') {\n        return super.add(decl, prefix);\n      }\n    } else if (p === 'list-style' || p === 'list-style-image' || p === 'content') {\n      if (prefix === '-webkit-' || prefix === '-webkit- old') {\n        return super.add(decl, prefix);\n      }\n    } else {\n      return super.add(decl, prefix);\n    }\n\n    return undefined;\n  }\n\n}\n\nGradient.names = ['linear-gradient', 'repeating-linear-gradient', 'radial-gradient', 'repeating-radial-gradient'];\nGradient.directions = {\n  top: 'bottom',\n  left: 'right',\n  bottom: 'top',\n  right: 'left'\n}; // Direction to replace\n\nGradient.oldDirections = {\n  'top': 'left bottom, left top',\n  'left': 'right top, left top',\n  'bottom': 'left top, left bottom',\n  'right': 'left top, right top',\n  'top right': 'left bottom, right top',\n  'top left': 'right bottom, left top',\n  'right top': 'left bottom, right top',\n  'right bottom': 'left top, right bottom',\n  'bottom right': 'left top, right bottom',\n  'bottom left': 'right top, left bottom',\n  'left top': 'right bottom, left top',\n  'left bottom': 'right top, left bottom'\n};\nmodule.exports = Gradient;","map":{"version":3,"names":["parser","require","range","OldValue","Value","utils","IS_DIRECTION","Gradient","replace","string","prefix","ast","node","nodes","type","value","name","newDirection","normalize","changes","oldWebkit","convertDirection","toString","replaceFirst","params","words","map","i","concat","slice","normalizeUnit","str","full","num","parseFloat","deg","test","Math","PI","includes","wrap","lastIndex","unshift","length","revertDirection","isRadial","state","param","fixDirection","fixAngle","fixRadial","splice","first","abs","roundFloat","second","a","b","c","next","push","div","word","directions","toLowerCase","float","digits","toFixed","stringify","oldDirection","colorStops","cloneDiv","oldDirections","bottom","join","old","after","result","pos","item","color","stop","regexp","add","decl","p","prop","undefined","names","top","left","right","module","exports"],"sources":["C:/Users/PC/Desktop/programaciÃ³n/VacunAssistIS2/Vacunassist/node_modules/autoprefixer/lib/hacks/gradient.js"],"sourcesContent":["let parser = require('postcss-value-parser')\nlet range = require('normalize-range')\n\nlet OldValue = require('../old-value')\nlet Value = require('../value')\nlet utils = require('../utils')\n\nlet IS_DIRECTION = /top|left|right|bottom/gi\n\nclass Gradient extends Value {\n  /**\n   * Change degrees for webkit prefix\n   */\n  replace(string, prefix) {\n    let ast = parser(string)\n    for (let node of ast.nodes) {\n      if (node.type === 'function' && node.value === this.name) {\n        node.nodes = this.newDirection(node.nodes)\n        node.nodes = this.normalize(node.nodes)\n        if (prefix === '-webkit- old') {\n          let changes = this.oldWebkit(node)\n          if (!changes) {\n            return false\n          }\n        } else {\n          node.nodes = this.convertDirection(node.nodes)\n          node.value = prefix + node.value\n        }\n      }\n    }\n    return ast.toString()\n  }\n\n  /**\n   * Replace first token\n   */\n  replaceFirst(params, ...words) {\n    let prefix = words.map(i => {\n      if (i === ' ') {\n        return { type: 'space', value: i }\n      }\n      return { type: 'word', value: i }\n    })\n    return prefix.concat(params.slice(1))\n  }\n\n  /**\n   * Convert angle unit to deg\n   */\n  normalizeUnit(str, full) {\n    let num = parseFloat(str)\n    let deg = (num / full) * 360\n    return `${deg}deg`\n  }\n\n  /**\n   * Normalize angle\n   */\n  normalize(nodes) {\n    if (!nodes[0]) return nodes\n\n    if (/-?\\d+(.\\d+)?grad/.test(nodes[0].value)) {\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 400)\n    } else if (/-?\\d+(.\\d+)?rad/.test(nodes[0].value)) {\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 2 * Math.PI)\n    } else if (/-?\\d+(.\\d+)?turn/.test(nodes[0].value)) {\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 1)\n    } else if (nodes[0].value.includes('deg')) {\n      let num = parseFloat(nodes[0].value)\n      num = range.wrap(0, 360, num)\n      nodes[0].value = `${num}deg`\n    }\n\n    if (nodes[0].value === '0deg') {\n      nodes = this.replaceFirst(nodes, 'to', ' ', 'top')\n    } else if (nodes[0].value === '90deg') {\n      nodes = this.replaceFirst(nodes, 'to', ' ', 'right')\n    } else if (nodes[0].value === '180deg') {\n      nodes = this.replaceFirst(nodes, 'to', ' ', 'bottom')\n    } else if (nodes[0].value === '270deg') {\n      nodes = this.replaceFirst(nodes, 'to', ' ', 'left')\n    }\n\n    return nodes\n  }\n\n  /**\n   * Replace old direction to new\n   */\n  newDirection(params) {\n    if (params[0].value === 'to') {\n      return params\n    }\n    IS_DIRECTION.lastIndex = 0 // reset search index of global regexp\n    if (!IS_DIRECTION.test(params[0].value)) {\n      return params\n    }\n\n    params.unshift(\n      {\n        type: 'word',\n        value: 'to'\n      },\n      {\n        type: 'space',\n        value: ' '\n      }\n    )\n\n    for (let i = 2; i < params.length; i++) {\n      if (params[i].type === 'div') {\n        break\n      }\n      if (params[i].type === 'word') {\n        params[i].value = this.revertDirection(params[i].value)\n      }\n    }\n\n    return params\n  }\n\n  /**\n   * Look for at word\n   */\n  isRadial(params) {\n    let state = 'before'\n    for (let param of params) {\n      if (state === 'before' && param.type === 'space') {\n        state = 'at'\n      } else if (state === 'at' && param.value === 'at') {\n        state = 'after'\n      } else if (state === 'after' && param.type === 'space') {\n        return true\n      } else if (param.type === 'div') {\n        break\n      } else {\n        state = 'before'\n      }\n    }\n    return false\n  }\n\n  /**\n   * Change new direction to old\n   */\n  convertDirection(params) {\n    if (params.length > 0) {\n      if (params[0].value === 'to') {\n        this.fixDirection(params)\n      } else if (params[0].value.includes('deg')) {\n        this.fixAngle(params)\n      } else if (this.isRadial(params)) {\n        this.fixRadial(params)\n      }\n    }\n    return params\n  }\n\n  /**\n   * Replace `to top left` to `bottom right`\n   */\n  fixDirection(params) {\n    params.splice(0, 2)\n\n    for (let param of params) {\n      if (param.type === 'div') {\n        break\n      }\n      if (param.type === 'word') {\n        param.value = this.revertDirection(param.value)\n      }\n    }\n  }\n\n  /**\n   * Add 90 degrees\n   */\n  fixAngle(params) {\n    let first = params[0].value\n    first = parseFloat(first)\n    first = Math.abs(450 - first) % 360\n    first = this.roundFloat(first, 3)\n    params[0].value = `${first}deg`\n  }\n\n  /**\n   * Fix radial direction syntax\n   */\n  fixRadial(params) {\n    let first = []\n    let second = []\n    let a, b, c, i, next\n\n    for (i = 0; i < params.length - 2; i++) {\n      a = params[i]\n      b = params[i + 1]\n      c = params[i + 2]\n      if (a.type === 'space' && b.value === 'at' && c.type === 'space') {\n        next = i + 3\n        break\n      } else {\n        first.push(a)\n      }\n    }\n\n    let div\n    for (i = next; i < params.length; i++) {\n      if (params[i].type === 'div') {\n        div = params[i]\n        break\n      } else {\n        second.push(params[i])\n      }\n    }\n\n    params.splice(0, i, ...second, div, ...first)\n  }\n\n  revertDirection(word) {\n    return Gradient.directions[word.toLowerCase()] || word\n  }\n\n  /**\n   * Round float and save digits under dot\n   */\n  roundFloat(float, digits) {\n    return parseFloat(float.toFixed(digits))\n  }\n\n  /**\n   * Convert to old webkit syntax\n   */\n  oldWebkit(node) {\n    let { nodes } = node\n    let string = parser.stringify(node.nodes)\n\n    if (this.name !== 'linear-gradient') {\n      return false\n    }\n    if (nodes[0] && nodes[0].value.includes('deg')) {\n      return false\n    }\n    if (\n      string.includes('px') ||\n      string.includes('-corner') ||\n      string.includes('-side')\n    ) {\n      return false\n    }\n\n    let params = [[]]\n    for (let i of nodes) {\n      params[params.length - 1].push(i)\n      if (i.type === 'div' && i.value === ',') {\n        params.push([])\n      }\n    }\n\n    this.oldDirection(params)\n    this.colorStops(params)\n\n    node.nodes = []\n    for (let param of params) {\n      node.nodes = node.nodes.concat(param)\n    }\n\n    node.nodes.unshift(\n      { type: 'word', value: 'linear' },\n      this.cloneDiv(node.nodes)\n    )\n    node.value = '-webkit-gradient'\n\n    return true\n  }\n\n  /**\n   * Change direction syntax to old webkit\n   */\n  oldDirection(params) {\n    let div = this.cloneDiv(params[0])\n\n    if (params[0][0].value !== 'to') {\n      return params.unshift([\n        { type: 'word', value: Gradient.oldDirections.bottom },\n        div\n      ])\n    } else {\n      let words = []\n      for (let node of params[0].slice(2)) {\n        if (node.type === 'word') {\n          words.push(node.value.toLowerCase())\n        }\n      }\n\n      words = words.join(' ')\n      let old = Gradient.oldDirections[words] || words\n\n      params[0] = [{ type: 'word', value: old }, div]\n      return params[0]\n    }\n  }\n\n  /**\n   * Get div token from exists parameters\n   */\n  cloneDiv(params) {\n    for (let i of params) {\n      if (i.type === 'div' && i.value === ',') {\n        return i\n      }\n    }\n    return { type: 'div', value: ',', after: ' ' }\n  }\n\n  /**\n   * Change colors syntax to old webkit\n   */\n  colorStops(params) {\n    let result = []\n    for (let i = 0; i < params.length; i++) {\n      let pos\n      let param = params[i]\n      let item\n      if (i === 0) {\n        continue\n      }\n\n      let color = parser.stringify(param[0])\n      if (param[1] && param[1].type === 'word') {\n        pos = param[1].value\n      } else if (param[2] && param[2].type === 'word') {\n        pos = param[2].value\n      }\n\n      let stop\n      if (i === 1 && (!pos || pos === '0%')) {\n        stop = `from(${color})`\n      } else if (i === params.length - 1 && (!pos || pos === '100%')) {\n        stop = `to(${color})`\n      } else if (pos) {\n        stop = `color-stop(${pos}, ${color})`\n      } else {\n        stop = `color-stop(${color})`\n      }\n\n      let div = param[param.length - 1]\n      params[i] = [{ type: 'word', value: stop }]\n      if (div.type === 'div' && div.value === ',') {\n        item = params[i].push(div)\n      }\n      result.push(item)\n    }\n    return result\n  }\n\n  /**\n   * Remove old WebKit gradient too\n   */\n  old(prefix) {\n    if (prefix === '-webkit-') {\n      let type = this.name === 'linear-gradient' ? 'linear' : 'radial'\n      let string = '-gradient'\n      let regexp = utils.regexp(\n        `-webkit-(${type}-gradient|gradient\\\\(\\\\s*${type})`,\n        false\n      )\n\n      return new OldValue(this.name, prefix + this.name, string, regexp)\n    } else {\n      return super.old(prefix)\n    }\n  }\n\n  /**\n   * Do not add non-webkit prefixes for list-style and object\n   */\n  add(decl, prefix) {\n    let p = decl.prop\n    if (p.includes('mask')) {\n      if (prefix === '-webkit-' || prefix === '-webkit- old') {\n        return super.add(decl, prefix)\n      }\n    } else if (\n      p === 'list-style' ||\n      p === 'list-style-image' ||\n      p === 'content'\n    ) {\n      if (prefix === '-webkit-' || prefix === '-webkit- old') {\n        return super.add(decl, prefix)\n      }\n    } else {\n      return super.add(decl, prefix)\n    }\n    return undefined\n  }\n}\n\nGradient.names = [\n  'linear-gradient',\n  'repeating-linear-gradient',\n  'radial-gradient',\n  'repeating-radial-gradient'\n]\n\nGradient.directions = {\n  top: 'bottom',\n  left: 'right',\n  bottom: 'top',\n  right: 'left'\n}\n\n// Direction to replace\nGradient.oldDirections = {\n  'top': 'left bottom, left top',\n  'left': 'right top, left top',\n  'bottom': 'left top, left bottom',\n  'right': 'left top, right top',\n\n  'top right': 'left bottom, right top',\n  'top left': 'right bottom, left top',\n  'right top': 'left bottom, right top',\n  'right bottom': 'left top, right bottom',\n  'bottom right': 'left top, right bottom',\n  'bottom left': 'right top, left bottom',\n  'left top': 'right bottom, left top',\n  'left bottom': 'right top, left bottom'\n}\n\nmodule.exports = Gradient\n"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,sBAAD,CAApB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,iBAAD,CAAnB;;AAEA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,cAAD,CAAtB;;AACA,IAAIG,KAAK,GAAGH,OAAO,CAAC,UAAD,CAAnB;;AACA,IAAII,KAAK,GAAGJ,OAAO,CAAC,UAAD,CAAnB;;AAEA,IAAIK,YAAY,GAAG,yBAAnB;;AAEA,MAAMC,QAAN,SAAuBH,KAAvB,CAA6B;EAC3B;AACF;AACA;EACEI,OAAO,CAACC,MAAD,EAASC,MAAT,EAAiB;IACtB,IAAIC,GAAG,GAAGX,MAAM,CAACS,MAAD,CAAhB;;IACA,KAAK,IAAIG,IAAT,IAAiBD,GAAG,CAACE,KAArB,EAA4B;MAC1B,IAAID,IAAI,CAACE,IAAL,KAAc,UAAd,IAA4BF,IAAI,CAACG,KAAL,KAAe,KAAKC,IAApD,EAA0D;QACxDJ,IAAI,CAACC,KAAL,GAAa,KAAKI,YAAL,CAAkBL,IAAI,CAACC,KAAvB,CAAb;QACAD,IAAI,CAACC,KAAL,GAAa,KAAKK,SAAL,CAAeN,IAAI,CAACC,KAApB,CAAb;;QACA,IAAIH,MAAM,KAAK,cAAf,EAA+B;UAC7B,IAAIS,OAAO,GAAG,KAAKC,SAAL,CAAeR,IAAf,CAAd;;UACA,IAAI,CAACO,OAAL,EAAc;YACZ,OAAO,KAAP;UACD;QACF,CALD,MAKO;UACLP,IAAI,CAACC,KAAL,GAAa,KAAKQ,gBAAL,CAAsBT,IAAI,CAACC,KAA3B,CAAb;UACAD,IAAI,CAACG,KAAL,GAAaL,MAAM,GAAGE,IAAI,CAACG,KAA3B;QACD;MACF;IACF;;IACD,OAAOJ,GAAG,CAACW,QAAJ,EAAP;EACD;EAED;AACF;AACA;;;EACEC,YAAY,CAACC,MAAD,EAAmB;IAAA,kCAAPC,KAAO;MAAPA,KAAO;IAAA;;IAC7B,IAAIf,MAAM,GAAGe,KAAK,CAACC,GAAN,CAAUC,CAAC,IAAI;MAC1B,IAAIA,CAAC,KAAK,GAAV,EAAe;QACb,OAAO;UAAEb,IAAI,EAAE,OAAR;UAAiBC,KAAK,EAAEY;QAAxB,CAAP;MACD;;MACD,OAAO;QAAEb,IAAI,EAAE,MAAR;QAAgBC,KAAK,EAAEY;MAAvB,CAAP;IACD,CALY,CAAb;IAMA,OAAOjB,MAAM,CAACkB,MAAP,CAAcJ,MAAM,CAACK,KAAP,CAAa,CAAb,CAAd,CAAP;EACD;EAED;AACF;AACA;;;EACEC,aAAa,CAACC,GAAD,EAAMC,IAAN,EAAY;IACvB,IAAIC,GAAG,GAAGC,UAAU,CAACH,GAAD,CAApB;IACA,IAAII,GAAG,GAAIF,GAAG,GAAGD,IAAP,GAAe,GAAzB;IACA,OAAQ,GAAEG,GAAI,KAAd;EACD;EAED;AACF;AACA;;;EACEjB,SAAS,CAACL,KAAD,EAAQ;IACf,IAAI,CAACA,KAAK,CAAC,CAAD,CAAV,EAAe,OAAOA,KAAP;;IAEf,IAAI,mBAAmBuB,IAAnB,CAAwBvB,KAAK,CAAC,CAAD,CAAL,CAASE,KAAjC,CAAJ,EAA6C;MAC3CF,KAAK,CAAC,CAAD,CAAL,CAASE,KAAT,GAAiB,KAAKe,aAAL,CAAmBjB,KAAK,CAAC,CAAD,CAAL,CAASE,KAA5B,EAAmC,GAAnC,CAAjB;IACD,CAFD,MAEO,IAAI,kBAAkBqB,IAAlB,CAAuBvB,KAAK,CAAC,CAAD,CAAL,CAASE,KAAhC,CAAJ,EAA4C;MACjDF,KAAK,CAAC,CAAD,CAAL,CAASE,KAAT,GAAiB,KAAKe,aAAL,CAAmBjB,KAAK,CAAC,CAAD,CAAL,CAASE,KAA5B,EAAmC,IAAIsB,IAAI,CAACC,EAA5C,CAAjB;IACD,CAFM,MAEA,IAAI,mBAAmBF,IAAnB,CAAwBvB,KAAK,CAAC,CAAD,CAAL,CAASE,KAAjC,CAAJ,EAA6C;MAClDF,KAAK,CAAC,CAAD,CAAL,CAASE,KAAT,GAAiB,KAAKe,aAAL,CAAmBjB,KAAK,CAAC,CAAD,CAAL,CAASE,KAA5B,EAAmC,CAAnC,CAAjB;IACD,CAFM,MAEA,IAAIF,KAAK,CAAC,CAAD,CAAL,CAASE,KAAT,CAAewB,QAAf,CAAwB,KAAxB,CAAJ,EAAoC;MACzC,IAAIN,GAAG,GAAGC,UAAU,CAACrB,KAAK,CAAC,CAAD,CAAL,CAASE,KAAV,CAApB;MACAkB,GAAG,GAAG/B,KAAK,CAACsC,IAAN,CAAW,CAAX,EAAc,GAAd,EAAmBP,GAAnB,CAAN;MACApB,KAAK,CAAC,CAAD,CAAL,CAASE,KAAT,GAAkB,GAAEkB,GAAI,KAAxB;IACD;;IAED,IAAIpB,KAAK,CAAC,CAAD,CAAL,CAASE,KAAT,KAAmB,MAAvB,EAA+B;MAC7BF,KAAK,GAAG,KAAKU,YAAL,CAAkBV,KAAlB,EAAyB,IAAzB,EAA+B,GAA/B,EAAoC,KAApC,CAAR;IACD,CAFD,MAEO,IAAIA,KAAK,CAAC,CAAD,CAAL,CAASE,KAAT,KAAmB,OAAvB,EAAgC;MACrCF,KAAK,GAAG,KAAKU,YAAL,CAAkBV,KAAlB,EAAyB,IAAzB,EAA+B,GAA/B,EAAoC,OAApC,CAAR;IACD,CAFM,MAEA,IAAIA,KAAK,CAAC,CAAD,CAAL,CAASE,KAAT,KAAmB,QAAvB,EAAiC;MACtCF,KAAK,GAAG,KAAKU,YAAL,CAAkBV,KAAlB,EAAyB,IAAzB,EAA+B,GAA/B,EAAoC,QAApC,CAAR;IACD,CAFM,MAEA,IAAIA,KAAK,CAAC,CAAD,CAAL,CAASE,KAAT,KAAmB,QAAvB,EAAiC;MACtCF,KAAK,GAAG,KAAKU,YAAL,CAAkBV,KAAlB,EAAyB,IAAzB,EAA+B,GAA/B,EAAoC,MAApC,CAAR;IACD;;IAED,OAAOA,KAAP;EACD;EAED;AACF;AACA;;;EACEI,YAAY,CAACO,MAAD,EAAS;IACnB,IAAIA,MAAM,CAAC,CAAD,CAAN,CAAUT,KAAV,KAAoB,IAAxB,EAA8B;MAC5B,OAAOS,MAAP;IACD;;IACDlB,YAAY,CAACmC,SAAb,GAAyB,CAAzB,CAJmB,CAIQ;;IAC3B,IAAI,CAACnC,YAAY,CAAC8B,IAAb,CAAkBZ,MAAM,CAAC,CAAD,CAAN,CAAUT,KAA5B,CAAL,EAAyC;MACvC,OAAOS,MAAP;IACD;;IAEDA,MAAM,CAACkB,OAAP,CACE;MACE5B,IAAI,EAAE,MADR;MAEEC,KAAK,EAAE;IAFT,CADF,EAKE;MACED,IAAI,EAAE,OADR;MAEEC,KAAK,EAAE;IAFT,CALF;;IAWA,KAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACmB,MAA3B,EAAmChB,CAAC,EAApC,EAAwC;MACtC,IAAIH,MAAM,CAACG,CAAD,CAAN,CAAUb,IAAV,KAAmB,KAAvB,EAA8B;QAC5B;MACD;;MACD,IAAIU,MAAM,CAACG,CAAD,CAAN,CAAUb,IAAV,KAAmB,MAAvB,EAA+B;QAC7BU,MAAM,CAACG,CAAD,CAAN,CAAUZ,KAAV,GAAkB,KAAK6B,eAAL,CAAqBpB,MAAM,CAACG,CAAD,CAAN,CAAUZ,KAA/B,CAAlB;MACD;IACF;;IAED,OAAOS,MAAP;EACD;EAED;AACF;AACA;;;EACEqB,QAAQ,CAACrB,MAAD,EAAS;IACf,IAAIsB,KAAK,GAAG,QAAZ;;IACA,KAAK,IAAIC,KAAT,IAAkBvB,MAAlB,EAA0B;MACxB,IAAIsB,KAAK,KAAK,QAAV,IAAsBC,KAAK,CAACjC,IAAN,KAAe,OAAzC,EAAkD;QAChDgC,KAAK,GAAG,IAAR;MACD,CAFD,MAEO,IAAIA,KAAK,KAAK,IAAV,IAAkBC,KAAK,CAAChC,KAAN,KAAgB,IAAtC,EAA4C;QACjD+B,KAAK,GAAG,OAAR;MACD,CAFM,MAEA,IAAIA,KAAK,KAAK,OAAV,IAAqBC,KAAK,CAACjC,IAAN,KAAe,OAAxC,EAAiD;QACtD,OAAO,IAAP;MACD,CAFM,MAEA,IAAIiC,KAAK,CAACjC,IAAN,KAAe,KAAnB,EAA0B;QAC/B;MACD,CAFM,MAEA;QACLgC,KAAK,GAAG,QAAR;MACD;IACF;;IACD,OAAO,KAAP;EACD;EAED;AACF;AACA;;;EACEzB,gBAAgB,CAACG,MAAD,EAAS;IACvB,IAAIA,MAAM,CAACmB,MAAP,GAAgB,CAApB,EAAuB;MACrB,IAAInB,MAAM,CAAC,CAAD,CAAN,CAAUT,KAAV,KAAoB,IAAxB,EAA8B;QAC5B,KAAKiC,YAAL,CAAkBxB,MAAlB;MACD,CAFD,MAEO,IAAIA,MAAM,CAAC,CAAD,CAAN,CAAUT,KAAV,CAAgBwB,QAAhB,CAAyB,KAAzB,CAAJ,EAAqC;QAC1C,KAAKU,QAAL,CAAczB,MAAd;MACD,CAFM,MAEA,IAAI,KAAKqB,QAAL,CAAcrB,MAAd,CAAJ,EAA2B;QAChC,KAAK0B,SAAL,CAAe1B,MAAf;MACD;IACF;;IACD,OAAOA,MAAP;EACD;EAED;AACF;AACA;;;EACEwB,YAAY,CAACxB,MAAD,EAAS;IACnBA,MAAM,CAAC2B,MAAP,CAAc,CAAd,EAAiB,CAAjB;;IAEA,KAAK,IAAIJ,KAAT,IAAkBvB,MAAlB,EAA0B;MACxB,IAAIuB,KAAK,CAACjC,IAAN,KAAe,KAAnB,EAA0B;QACxB;MACD;;MACD,IAAIiC,KAAK,CAACjC,IAAN,KAAe,MAAnB,EAA2B;QACzBiC,KAAK,CAAChC,KAAN,GAAc,KAAK6B,eAAL,CAAqBG,KAAK,CAAChC,KAA3B,CAAd;MACD;IACF;EACF;EAED;AACF;AACA;;;EACEkC,QAAQ,CAACzB,MAAD,EAAS;IACf,IAAI4B,KAAK,GAAG5B,MAAM,CAAC,CAAD,CAAN,CAAUT,KAAtB;IACAqC,KAAK,GAAGlB,UAAU,CAACkB,KAAD,CAAlB;IACAA,KAAK,GAAGf,IAAI,CAACgB,GAAL,CAAS,MAAMD,KAAf,IAAwB,GAAhC;IACAA,KAAK,GAAG,KAAKE,UAAL,CAAgBF,KAAhB,EAAuB,CAAvB,CAAR;IACA5B,MAAM,CAAC,CAAD,CAAN,CAAUT,KAAV,GAAmB,GAAEqC,KAAM,KAA3B;EACD;EAED;AACF;AACA;;;EACEF,SAAS,CAAC1B,MAAD,EAAS;IAChB,IAAI4B,KAAK,GAAG,EAAZ;IACA,IAAIG,MAAM,GAAG,EAAb;IACA,IAAIC,CAAJ,EAAOC,CAAP,EAAUC,CAAV,EAAa/B,CAAb,EAAgBgC,IAAhB;;IAEA,KAAKhC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGH,MAAM,CAACmB,MAAP,GAAgB,CAAhC,EAAmChB,CAAC,EAApC,EAAwC;MACtC6B,CAAC,GAAGhC,MAAM,CAACG,CAAD,CAAV;MACA8B,CAAC,GAAGjC,MAAM,CAACG,CAAC,GAAG,CAAL,CAAV;MACA+B,CAAC,GAAGlC,MAAM,CAACG,CAAC,GAAG,CAAL,CAAV;;MACA,IAAI6B,CAAC,CAAC1C,IAAF,KAAW,OAAX,IAAsB2C,CAAC,CAAC1C,KAAF,KAAY,IAAlC,IAA0C2C,CAAC,CAAC5C,IAAF,KAAW,OAAzD,EAAkE;QAChE6C,IAAI,GAAGhC,CAAC,GAAG,CAAX;QACA;MACD,CAHD,MAGO;QACLyB,KAAK,CAACQ,IAAN,CAAWJ,CAAX;MACD;IACF;;IAED,IAAIK,GAAJ;;IACA,KAAKlC,CAAC,GAAGgC,IAAT,EAAehC,CAAC,GAAGH,MAAM,CAACmB,MAA1B,EAAkChB,CAAC,EAAnC,EAAuC;MACrC,IAAIH,MAAM,CAACG,CAAD,CAAN,CAAUb,IAAV,KAAmB,KAAvB,EAA8B;QAC5B+C,GAAG,GAAGrC,MAAM,CAACG,CAAD,CAAZ;QACA;MACD,CAHD,MAGO;QACL4B,MAAM,CAACK,IAAP,CAAYpC,MAAM,CAACG,CAAD,CAAlB;MACD;IACF;;IAEDH,MAAM,CAAC2B,MAAP,CAAc,CAAd,EAAiBxB,CAAjB,EAAoB,GAAG4B,MAAvB,EAA+BM,GAA/B,EAAoC,GAAGT,KAAvC;EACD;;EAEDR,eAAe,CAACkB,IAAD,EAAO;IACpB,OAAOvD,QAAQ,CAACwD,UAAT,CAAoBD,IAAI,CAACE,WAAL,EAApB,KAA2CF,IAAlD;EACD;EAED;AACF;AACA;;;EACER,UAAU,CAACW,KAAD,EAAQC,MAAR,EAAgB;IACxB,OAAOhC,UAAU,CAAC+B,KAAK,CAACE,OAAN,CAAcD,MAAd,CAAD,CAAjB;EACD;EAED;AACF;AACA;;;EACE9C,SAAS,CAACR,IAAD,EAAO;IACd,IAAI;MAAEC;IAAF,IAAYD,IAAhB;IACA,IAAIH,MAAM,GAAGT,MAAM,CAACoE,SAAP,CAAiBxD,IAAI,CAACC,KAAtB,CAAb;;IAEA,IAAI,KAAKG,IAAL,KAAc,iBAAlB,EAAqC;MACnC,OAAO,KAAP;IACD;;IACD,IAAIH,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAAL,CAASE,KAAT,CAAewB,QAAf,CAAwB,KAAxB,CAAhB,EAAgD;MAC9C,OAAO,KAAP;IACD;;IACD,IACE9B,MAAM,CAAC8B,QAAP,CAAgB,IAAhB,KACA9B,MAAM,CAAC8B,QAAP,CAAgB,SAAhB,CADA,IAEA9B,MAAM,CAAC8B,QAAP,CAAgB,OAAhB,CAHF,EAIE;MACA,OAAO,KAAP;IACD;;IAED,IAAIf,MAAM,GAAG,CAAC,EAAD,CAAb;;IACA,KAAK,IAAIG,CAAT,IAAcd,KAAd,EAAqB;MACnBW,MAAM,CAACA,MAAM,CAACmB,MAAP,GAAgB,CAAjB,CAAN,CAA0BiB,IAA1B,CAA+BjC,CAA/B;;MACA,IAAIA,CAAC,CAACb,IAAF,KAAW,KAAX,IAAoBa,CAAC,CAACZ,KAAF,KAAY,GAApC,EAAyC;QACvCS,MAAM,CAACoC,IAAP,CAAY,EAAZ;MACD;IACF;;IAED,KAAKS,YAAL,CAAkB7C,MAAlB;IACA,KAAK8C,UAAL,CAAgB9C,MAAhB;IAEAZ,IAAI,CAACC,KAAL,GAAa,EAAb;;IACA,KAAK,IAAIkC,KAAT,IAAkBvB,MAAlB,EAA0B;MACxBZ,IAAI,CAACC,KAAL,GAAaD,IAAI,CAACC,KAAL,CAAWe,MAAX,CAAkBmB,KAAlB,CAAb;IACD;;IAEDnC,IAAI,CAACC,KAAL,CAAW6B,OAAX,CACE;MAAE5B,IAAI,EAAE,MAAR;MAAgBC,KAAK,EAAE;IAAvB,CADF,EAEE,KAAKwD,QAAL,CAAc3D,IAAI,CAACC,KAAnB,CAFF;IAIAD,IAAI,CAACG,KAAL,GAAa,kBAAb;IAEA,OAAO,IAAP;EACD;EAED;AACF;AACA;;;EACEsD,YAAY,CAAC7C,MAAD,EAAS;IACnB,IAAIqC,GAAG,GAAG,KAAKU,QAAL,CAAc/C,MAAM,CAAC,CAAD,CAApB,CAAV;;IAEA,IAAIA,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,EAAaT,KAAb,KAAuB,IAA3B,EAAiC;MAC/B,OAAOS,MAAM,CAACkB,OAAP,CAAe,CACpB;QAAE5B,IAAI,EAAE,MAAR;QAAgBC,KAAK,EAAER,QAAQ,CAACiE,aAAT,CAAuBC;MAA9C,CADoB,EAEpBZ,GAFoB,CAAf,CAAP;IAID,CALD,MAKO;MACL,IAAIpC,KAAK,GAAG,EAAZ;;MACA,KAAK,IAAIb,IAAT,IAAiBY,MAAM,CAAC,CAAD,CAAN,CAAUK,KAAV,CAAgB,CAAhB,CAAjB,EAAqC;QACnC,IAAIjB,IAAI,CAACE,IAAL,KAAc,MAAlB,EAA0B;UACxBW,KAAK,CAACmC,IAAN,CAAWhD,IAAI,CAACG,KAAL,CAAWiD,WAAX,EAAX;QACD;MACF;;MAEDvC,KAAK,GAAGA,KAAK,CAACiD,IAAN,CAAW,GAAX,CAAR;MACA,IAAIC,GAAG,GAAGpE,QAAQ,CAACiE,aAAT,CAAuB/C,KAAvB,KAAiCA,KAA3C;MAEAD,MAAM,CAAC,CAAD,CAAN,GAAY,CAAC;QAAEV,IAAI,EAAE,MAAR;QAAgBC,KAAK,EAAE4D;MAAvB,CAAD,EAA+Bd,GAA/B,CAAZ;MACA,OAAOrC,MAAM,CAAC,CAAD,CAAb;IACD;EACF;EAED;AACF;AACA;;;EACE+C,QAAQ,CAAC/C,MAAD,EAAS;IACf,KAAK,IAAIG,CAAT,IAAcH,MAAd,EAAsB;MACpB,IAAIG,CAAC,CAACb,IAAF,KAAW,KAAX,IAAoBa,CAAC,CAACZ,KAAF,KAAY,GAApC,EAAyC;QACvC,OAAOY,CAAP;MACD;IACF;;IACD,OAAO;MAAEb,IAAI,EAAE,KAAR;MAAeC,KAAK,EAAE,GAAtB;MAA2B6D,KAAK,EAAE;IAAlC,CAAP;EACD;EAED;AACF;AACA;;;EACEN,UAAU,CAAC9C,MAAD,EAAS;IACjB,IAAIqD,MAAM,GAAG,EAAb;;IACA,KAAK,IAAIlD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACmB,MAA3B,EAAmChB,CAAC,EAApC,EAAwC;MACtC,IAAImD,GAAJ;MACA,IAAI/B,KAAK,GAAGvB,MAAM,CAACG,CAAD,CAAlB;MACA,IAAIoD,IAAJ;;MACA,IAAIpD,CAAC,KAAK,CAAV,EAAa;QACX;MACD;;MAED,IAAIqD,KAAK,GAAGhF,MAAM,CAACoE,SAAP,CAAiBrB,KAAK,CAAC,CAAD,CAAtB,CAAZ;;MACA,IAAIA,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAAL,CAASjC,IAAT,KAAkB,MAAlC,EAA0C;QACxCgE,GAAG,GAAG/B,KAAK,CAAC,CAAD,CAAL,CAAShC,KAAf;MACD,CAFD,MAEO,IAAIgC,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAAL,CAASjC,IAAT,KAAkB,MAAlC,EAA0C;QAC/CgE,GAAG,GAAG/B,KAAK,CAAC,CAAD,CAAL,CAAShC,KAAf;MACD;;MAED,IAAIkE,IAAJ;;MACA,IAAItD,CAAC,KAAK,CAAN,KAAY,CAACmD,GAAD,IAAQA,GAAG,KAAK,IAA5B,CAAJ,EAAuC;QACrCG,IAAI,GAAI,QAAOD,KAAM,GAArB;MACD,CAFD,MAEO,IAAIrD,CAAC,KAAKH,MAAM,CAACmB,MAAP,GAAgB,CAAtB,KAA4B,CAACmC,GAAD,IAAQA,GAAG,KAAK,MAA5C,CAAJ,EAAyD;QAC9DG,IAAI,GAAI,MAAKD,KAAM,GAAnB;MACD,CAFM,MAEA,IAAIF,GAAJ,EAAS;QACdG,IAAI,GAAI,cAAaH,GAAI,KAAIE,KAAM,GAAnC;MACD,CAFM,MAEA;QACLC,IAAI,GAAI,cAAaD,KAAM,GAA3B;MACD;;MAED,IAAInB,GAAG,GAAGd,KAAK,CAACA,KAAK,CAACJ,MAAN,GAAe,CAAhB,CAAf;MACAnB,MAAM,CAACG,CAAD,CAAN,GAAY,CAAC;QAAEb,IAAI,EAAE,MAAR;QAAgBC,KAAK,EAAEkE;MAAvB,CAAD,CAAZ;;MACA,IAAIpB,GAAG,CAAC/C,IAAJ,KAAa,KAAb,IAAsB+C,GAAG,CAAC9C,KAAJ,KAAc,GAAxC,EAA6C;QAC3CgE,IAAI,GAAGvD,MAAM,CAACG,CAAD,CAAN,CAAUiC,IAAV,CAAeC,GAAf,CAAP;MACD;;MACDgB,MAAM,CAACjB,IAAP,CAAYmB,IAAZ;IACD;;IACD,OAAOF,MAAP;EACD;EAED;AACF;AACA;;;EACEF,GAAG,CAACjE,MAAD,EAAS;IACV,IAAIA,MAAM,KAAK,UAAf,EAA2B;MACzB,IAAII,IAAI,GAAG,KAAKE,IAAL,KAAc,iBAAd,GAAkC,QAAlC,GAA6C,QAAxD;MACA,IAAIP,MAAM,GAAG,WAAb;MACA,IAAIyE,MAAM,GAAG7E,KAAK,CAAC6E,MAAN,CACV,YAAWpE,IAAK,4BAA2BA,IAAK,GADtC,EAEX,KAFW,CAAb;MAKA,OAAO,IAAIX,QAAJ,CAAa,KAAKa,IAAlB,EAAwBN,MAAM,GAAG,KAAKM,IAAtC,EAA4CP,MAA5C,EAAoDyE,MAApD,CAAP;IACD,CATD,MASO;MACL,OAAO,MAAMP,GAAN,CAAUjE,MAAV,CAAP;IACD;EACF;EAED;AACF;AACA;;;EACEyE,GAAG,CAACC,IAAD,EAAO1E,MAAP,EAAe;IAChB,IAAI2E,CAAC,GAAGD,IAAI,CAACE,IAAb;;IACA,IAAID,CAAC,CAAC9C,QAAF,CAAW,MAAX,CAAJ,EAAwB;MACtB,IAAI7B,MAAM,KAAK,UAAX,IAAyBA,MAAM,KAAK,cAAxC,EAAwD;QACtD,OAAO,MAAMyE,GAAN,CAAUC,IAAV,EAAgB1E,MAAhB,CAAP;MACD;IACF,CAJD,MAIO,IACL2E,CAAC,KAAK,YAAN,IACAA,CAAC,KAAK,kBADN,IAEAA,CAAC,KAAK,SAHD,EAIL;MACA,IAAI3E,MAAM,KAAK,UAAX,IAAyBA,MAAM,KAAK,cAAxC,EAAwD;QACtD,OAAO,MAAMyE,GAAN,CAAUC,IAAV,EAAgB1E,MAAhB,CAAP;MACD;IACF,CARM,MAQA;MACL,OAAO,MAAMyE,GAAN,CAAUC,IAAV,EAAgB1E,MAAhB,CAAP;IACD;;IACD,OAAO6E,SAAP;EACD;;AAjY0B;;AAoY7BhF,QAAQ,CAACiF,KAAT,GAAiB,CACf,iBADe,EAEf,2BAFe,EAGf,iBAHe,EAIf,2BAJe,CAAjB;AAOAjF,QAAQ,CAACwD,UAAT,GAAsB;EACpB0B,GAAG,EAAE,QADe;EAEpBC,IAAI,EAAE,OAFc;EAGpBjB,MAAM,EAAE,KAHY;EAIpBkB,KAAK,EAAE;AAJa,CAAtB,C,CAOA;;AACApF,QAAQ,CAACiE,aAAT,GAAyB;EACvB,OAAO,uBADgB;EAEvB,QAAQ,qBAFe;EAGvB,UAAU,uBAHa;EAIvB,SAAS,qBAJc;EAMvB,aAAa,wBANU;EAOvB,YAAY,wBAPW;EAQvB,aAAa,wBARU;EASvB,gBAAgB,wBATO;EAUvB,gBAAgB,wBAVO;EAWvB,eAAe,wBAXQ;EAYvB,YAAY,wBAZW;EAavB,eAAe;AAbQ,CAAzB;AAgBAoB,MAAM,CAACC,OAAP,GAAiBtF,QAAjB"},"metadata":{},"sourceType":"script"}