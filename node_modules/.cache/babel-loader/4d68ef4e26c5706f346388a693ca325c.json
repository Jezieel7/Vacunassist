{"ast":null,"code":"let Prefixer = require('./prefixer');\n\nlet Browsers = require('./browsers');\n\nlet utils = require('./utils');\n\nclass Declaration extends Prefixer {\n  /**\n   * Always true, because we already get prefixer by property name\n   */\n  check() {\n    return true;\n  }\n  /**\n   * Return prefixed version of property\n   */\n\n\n  prefixed(prop, prefix) {\n    return prefix + prop;\n  }\n  /**\n   * Return unprefixed version of property\n   */\n\n\n  normalize(prop) {\n    return prop;\n  }\n  /**\n   * Check `value`, that it contain other prefixes, rather than `prefix`\n   */\n\n\n  otherPrefixes(value, prefix) {\n    for (let other of Browsers.prefixes()) {\n      if (other === prefix) {\n        continue;\n      }\n\n      if (value.includes(other)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Set prefix to declaration\n   */\n\n\n  set(decl, prefix) {\n    decl.prop = this.prefixed(decl.prop, prefix);\n    return decl;\n  }\n  /**\n   * Should we use visual cascade for prefixes\n   */\n\n\n  needCascade(decl) {\n    if (!decl._autoprefixerCascade) {\n      decl._autoprefixerCascade = this.all.options.cascade !== false && decl.raw('before').includes('\\n');\n    }\n\n    return decl._autoprefixerCascade;\n  }\n  /**\n   * Return maximum length of possible prefixed property\n   */\n\n\n  maxPrefixed(prefixes, decl) {\n    if (decl._autoprefixerMax) {\n      return decl._autoprefixerMax;\n    }\n\n    let max = 0;\n\n    for (let prefix of prefixes) {\n      prefix = utils.removeNote(prefix);\n\n      if (prefix.length > max) {\n        max = prefix.length;\n      }\n    }\n\n    decl._autoprefixerMax = max;\n    return decl._autoprefixerMax;\n  }\n  /**\n   * Calculate indentation to create visual cascade\n   */\n\n\n  calcBefore(prefixes, decl) {\n    let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let max = this.maxPrefixed(prefixes, decl);\n    let diff = max - utils.removeNote(prefix).length;\n    let before = decl.raw('before');\n\n    if (diff > 0) {\n      before += Array(diff).fill(' ').join('');\n    }\n\n    return before;\n  }\n  /**\n   * Remove visual cascade\n   */\n\n\n  restoreBefore(decl) {\n    let lines = decl.raw('before').split('\\n');\n    let min = lines[lines.length - 1];\n    this.all.group(decl).up(prefixed => {\n      let array = prefixed.raw('before').split('\\n');\n      let last = array[array.length - 1];\n\n      if (last.length < min.length) {\n        min = last;\n      }\n    });\n    lines[lines.length - 1] = min;\n    decl.raws.before = lines.join('\\n');\n  }\n  /**\n   * Clone and insert new declaration\n   */\n\n\n  insert(decl, prefix, prefixes) {\n    let cloned = this.set(this.clone(decl), prefix);\n    if (!cloned) return undefined;\n    let already = decl.parent.some(i => i.prop === cloned.prop && i.value === cloned.value);\n\n    if (already) {\n      return undefined;\n    }\n\n    if (this.needCascade(decl)) {\n      cloned.raws.before = this.calcBefore(prefixes, decl, prefix);\n    }\n\n    return decl.parent.insertBefore(decl, cloned);\n  }\n  /**\n   * Did this declaration has this prefix above\n   */\n\n\n  isAlready(decl, prefixed) {\n    let already = this.all.group(decl).up(i => i.prop === prefixed);\n\n    if (!already) {\n      already = this.all.group(decl).down(i => i.prop === prefixed);\n    }\n\n    return already;\n  }\n  /**\n   * Clone and add prefixes for declaration\n   */\n\n\n  add(decl, prefix, prefixes, result) {\n    let prefixed = this.prefixed(decl.prop, prefix);\n\n    if (this.isAlready(decl, prefixed) || this.otherPrefixes(decl.value, prefix)) {\n      return undefined;\n    }\n\n    return this.insert(decl, prefix, prefixes, result);\n  }\n  /**\n   * Add spaces for visual cascade\n   */\n\n\n  process(decl, result) {\n    if (!this.needCascade(decl)) {\n      super.process(decl, result);\n      return;\n    }\n\n    let prefixes = super.process(decl, result);\n\n    if (!prefixes || !prefixes.length) {\n      return;\n    }\n\n    this.restoreBefore(decl);\n    decl.raws.before = this.calcBefore(prefixes, decl);\n  }\n  /**\n   * Return list of prefixed properties to clean old prefixes\n   */\n\n\n  old(prop, prefix) {\n    return [this.prefixed(prop, prefix)];\n  }\n\n}\n\nmodule.exports = Declaration;","map":{"version":3,"names":["Prefixer","require","Browsers","utils","Declaration","check","prefixed","prop","prefix","normalize","otherPrefixes","value","other","prefixes","includes","set","decl","needCascade","_autoprefixerCascade","all","options","cascade","raw","maxPrefixed","_autoprefixerMax","max","removeNote","length","calcBefore","diff","before","Array","fill","join","restoreBefore","lines","split","min","group","up","array","last","raws","insert","cloned","clone","undefined","already","parent","some","i","insertBefore","isAlready","down","add","result","process","old","module","exports"],"sources":["C:/Users/PC/Desktop/programaciÃ³n/VacunAssistIS2/Vacunassist/node_modules/autoprefixer/lib/declaration.js"],"sourcesContent":["let Prefixer = require('./prefixer')\nlet Browsers = require('./browsers')\nlet utils = require('./utils')\n\nclass Declaration extends Prefixer {\n  /**\n   * Always true, because we already get prefixer by property name\n   */\n  check(/* decl */) {\n    return true\n  }\n\n  /**\n   * Return prefixed version of property\n   */\n  prefixed(prop, prefix) {\n    return prefix + prop\n  }\n\n  /**\n   * Return unprefixed version of property\n   */\n  normalize(prop) {\n    return prop\n  }\n\n  /**\n   * Check `value`, that it contain other prefixes, rather than `prefix`\n   */\n  otherPrefixes(value, prefix) {\n    for (let other of Browsers.prefixes()) {\n      if (other === prefix) {\n        continue\n      }\n      if (value.includes(other)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * Set prefix to declaration\n   */\n  set(decl, prefix) {\n    decl.prop = this.prefixed(decl.prop, prefix)\n    return decl\n  }\n\n  /**\n   * Should we use visual cascade for prefixes\n   */\n  needCascade(decl) {\n    if (!decl._autoprefixerCascade) {\n      decl._autoprefixerCascade =\n        this.all.options.cascade !== false && decl.raw('before').includes('\\n')\n    }\n    return decl._autoprefixerCascade\n  }\n\n  /**\n   * Return maximum length of possible prefixed property\n   */\n  maxPrefixed(prefixes, decl) {\n    if (decl._autoprefixerMax) {\n      return decl._autoprefixerMax\n    }\n\n    let max = 0\n    for (let prefix of prefixes) {\n      prefix = utils.removeNote(prefix)\n      if (prefix.length > max) {\n        max = prefix.length\n      }\n    }\n    decl._autoprefixerMax = max\n\n    return decl._autoprefixerMax\n  }\n\n  /**\n   * Calculate indentation to create visual cascade\n   */\n  calcBefore(prefixes, decl, prefix = '') {\n    let max = this.maxPrefixed(prefixes, decl)\n    let diff = max - utils.removeNote(prefix).length\n\n    let before = decl.raw('before')\n    if (diff > 0) {\n      before += Array(diff).fill(' ').join('')\n    }\n\n    return before\n  }\n\n  /**\n   * Remove visual cascade\n   */\n  restoreBefore(decl) {\n    let lines = decl.raw('before').split('\\n')\n    let min = lines[lines.length - 1]\n\n    this.all.group(decl).up(prefixed => {\n      let array = prefixed.raw('before').split('\\n')\n      let last = array[array.length - 1]\n      if (last.length < min.length) {\n        min = last\n      }\n    })\n\n    lines[lines.length - 1] = min\n    decl.raws.before = lines.join('\\n')\n  }\n\n  /**\n   * Clone and insert new declaration\n   */\n  insert(decl, prefix, prefixes) {\n    let cloned = this.set(this.clone(decl), prefix)\n    if (!cloned) return undefined\n\n    let already = decl.parent.some(\n      i => i.prop === cloned.prop && i.value === cloned.value\n    )\n    if (already) {\n      return undefined\n    }\n\n    if (this.needCascade(decl)) {\n      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)\n    }\n    return decl.parent.insertBefore(decl, cloned)\n  }\n\n  /**\n   * Did this declaration has this prefix above\n   */\n  isAlready(decl, prefixed) {\n    let already = this.all.group(decl).up(i => i.prop === prefixed)\n    if (!already) {\n      already = this.all.group(decl).down(i => i.prop === prefixed)\n    }\n    return already\n  }\n\n  /**\n   * Clone and add prefixes for declaration\n   */\n  add(decl, prefix, prefixes, result) {\n    let prefixed = this.prefixed(decl.prop, prefix)\n    if (\n      this.isAlready(decl, prefixed) ||\n      this.otherPrefixes(decl.value, prefix)\n    ) {\n      return undefined\n    }\n    return this.insert(decl, prefix, prefixes, result)\n  }\n\n  /**\n   * Add spaces for visual cascade\n   */\n  process(decl, result) {\n    if (!this.needCascade(decl)) {\n      super.process(decl, result)\n      return\n    }\n\n    let prefixes = super.process(decl, result)\n\n    if (!prefixes || !prefixes.length) {\n      return\n    }\n\n    this.restoreBefore(decl)\n    decl.raws.before = this.calcBefore(prefixes, decl)\n  }\n\n  /**\n   * Return list of prefixed properties to clean old prefixes\n   */\n  old(prop, prefix) {\n    return [this.prefixed(prop, prefix)]\n  }\n}\n\nmodule.exports = Declaration\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}