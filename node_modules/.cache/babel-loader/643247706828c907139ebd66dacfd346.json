{"ast":null,"code":"let featureQueries = require('caniuse-lite/data/features/css-featurequeries.js');\n\nlet {\n  feature\n} = require('caniuse-lite');\n\nlet {\n  parse\n} = require('postcss');\n\nlet Browsers = require('./browsers');\n\nlet brackets = require('./brackets');\n\nlet Value = require('./value');\n\nlet utils = require('./utils');\n\nlet data = feature(featureQueries);\nlet supported = [];\n\nfor (let browser in data.stats) {\n  let versions = data.stats[browser];\n\n  for (let version in versions) {\n    let support = versions[version];\n\n    if (/y/.test(support)) {\n      supported.push(browser + ' ' + version);\n    }\n  }\n}\n\nclass Supports {\n  constructor(Prefixes, all) {\n    this.Prefixes = Prefixes;\n    this.all = all;\n  }\n  /**\n   * Return prefixer only with @supports supported browsers\n   */\n\n\n  prefixer() {\n    if (this.prefixerCache) {\n      return this.prefixerCache;\n    }\n\n    let filtered = this.all.browsers.selected.filter(i => {\n      return supported.includes(i);\n    });\n    let browsers = new Browsers(this.all.browsers.data, filtered, this.all.options);\n    this.prefixerCache = new this.Prefixes(this.all.data, browsers, this.all.options);\n    return this.prefixerCache;\n  }\n  /**\n   * Parse string into declaration property and value\n   */\n\n\n  parse(str) {\n    let parts = str.split(':');\n    let prop = parts[0];\n    let value = parts[1];\n    if (!value) value = '';\n    return [prop.trim(), value.trim()];\n  }\n  /**\n   * Create virtual rule to process it by prefixer\n   */\n\n\n  virtual(str) {\n    let [prop, value] = this.parse(str);\n    let rule = parse('a{}').first;\n    rule.append({\n      prop,\n      value,\n      raws: {\n        before: ''\n      }\n    });\n    return rule;\n  }\n  /**\n   * Return array of Declaration with all necessary prefixes\n   */\n\n\n  prefixed(str) {\n    let rule = this.virtual(str);\n\n    if (this.disabled(rule.first)) {\n      return rule.nodes;\n    }\n\n    let result = {\n      warn: () => null\n    };\n    let prefixer = this.prefixer().add[rule.first.prop];\n    prefixer && prefixer.process && prefixer.process(rule.first, result);\n\n    for (let decl of rule.nodes) {\n      for (let value of this.prefixer().values('add', rule.first.prop)) {\n        value.process(decl);\n      }\n\n      Value.save(this.all, decl);\n    }\n\n    return rule.nodes;\n  }\n  /**\n   * Return true if brackets node is \"not\" word\n   */\n\n\n  isNot(node) {\n    return typeof node === 'string' && /not\\s*/i.test(node);\n  }\n  /**\n   * Return true if brackets node is \"or\" word\n   */\n\n\n  isOr(node) {\n    return typeof node === 'string' && /\\s*or\\s*/i.test(node);\n  }\n  /**\n   * Return true if brackets node is (prop: value)\n   */\n\n\n  isProp(node) {\n    return typeof node === 'object' && node.length === 1 && typeof node[0] === 'string';\n  }\n  /**\n   * Return true if prefixed property has no unprefixed\n   */\n\n\n  isHack(all, unprefixed) {\n    let check = new RegExp(`(\\\\(|\\\\s)${utils.escapeRegexp(unprefixed)}:`);\n    return !check.test(all);\n  }\n  /**\n   * Return true if we need to remove node\n   */\n\n\n  toRemove(str, all) {\n    let [prop, value] = this.parse(str);\n    let unprefixed = this.all.unprefixed(prop);\n    let cleaner = this.all.cleaner();\n\n    if (cleaner.remove[prop] && cleaner.remove[prop].remove && !this.isHack(all, unprefixed)) {\n      return true;\n    }\n\n    for (let checker of cleaner.values('remove', unprefixed)) {\n      if (checker.check(value)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Remove all unnecessary prefixes\n   */\n\n\n  remove(nodes, all) {\n    let i = 0;\n\n    while (i < nodes.length) {\n      if (!this.isNot(nodes[i - 1]) && this.isProp(nodes[i]) && this.isOr(nodes[i + 1])) {\n        if (this.toRemove(nodes[i][0], all)) {\n          nodes.splice(i, 2);\n          continue;\n        }\n\n        i += 2;\n        continue;\n      }\n\n      if (typeof nodes[i] === 'object') {\n        nodes[i] = this.remove(nodes[i], all);\n      }\n\n      i += 1;\n    }\n\n    return nodes;\n  }\n  /**\n   * Clean brackets with one child\n   */\n\n\n  cleanBrackets(nodes) {\n    return nodes.map(i => {\n      if (typeof i !== 'object') {\n        return i;\n      }\n\n      if (i.length === 1 && typeof i[0] === 'object') {\n        return this.cleanBrackets(i[0]);\n      }\n\n      return this.cleanBrackets(i);\n    });\n  }\n  /**\n   * Add \" or \" between properties and convert it to brackets format\n   */\n\n\n  convert(progress) {\n    let result = [''];\n\n    for (let i of progress) {\n      result.push([`${i.prop}: ${i.value}`]);\n      result.push(' or ');\n    }\n\n    result[result.length - 1] = '';\n    return result;\n  }\n  /**\n   * Compress value functions into a string nodes\n   */\n\n\n  normalize(nodes) {\n    if (typeof nodes !== 'object') {\n      return nodes;\n    }\n\n    nodes = nodes.filter(i => i !== '');\n\n    if (typeof nodes[0] === 'string') {\n      let firstNode = nodes[0].trim();\n\n      if (firstNode.includes(':') || firstNode === 'selector' || firstNode === 'not selector') {\n        return [brackets.stringify(nodes)];\n      }\n    }\n\n    return nodes.map(i => this.normalize(i));\n  }\n  /**\n   * Add prefixes\n   */\n\n\n  add(nodes, all) {\n    return nodes.map(i => {\n      if (this.isProp(i)) {\n        let prefixed = this.prefixed(i[0]);\n\n        if (prefixed.length > 1) {\n          return this.convert(prefixed);\n        }\n\n        return i;\n      }\n\n      if (typeof i === 'object') {\n        return this.add(i, all);\n      }\n\n      return i;\n    });\n  }\n  /**\n   * Add prefixed declaration\n   */\n\n\n  process(rule) {\n    let ast = brackets.parse(rule.params);\n    ast = this.normalize(ast);\n    ast = this.remove(ast, rule.params);\n    ast = this.add(ast, rule.params);\n    ast = this.cleanBrackets(ast);\n    rule.params = brackets.stringify(ast);\n  }\n  /**\n   * Check global options\n   */\n\n\n  disabled(node) {\n    if (!this.all.options.grid) {\n      if (node.prop === 'display' && node.value.includes('grid')) {\n        return true;\n      }\n\n      if (node.prop.includes('grid') || node.prop === 'justify-items') {\n        return true;\n      }\n    }\n\n    if (this.all.options.flexbox === false) {\n      if (node.prop === 'display' && node.value.includes('flex')) {\n        return true;\n      }\n\n      let other = ['order', 'justify-content', 'align-items', 'align-content'];\n\n      if (node.prop.includes('flex') || other.includes(node.prop)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nmodule.exports = Supports;","map":{"version":3,"names":["featureQueries","require","feature","parse","Browsers","brackets","Value","utils","data","supported","browser","stats","versions","version","support","test","push","Supports","constructor","Prefixes","all","prefixer","prefixerCache","filtered","browsers","selected","filter","i","includes","options","str","parts","split","prop","value","trim","virtual","rule","first","append","raws","before","prefixed","disabled","nodes","result","warn","add","process","decl","values","save","isNot","node","isOr","isProp","length","isHack","unprefixed","check","RegExp","escapeRegexp","toRemove","cleaner","remove","checker","splice","cleanBrackets","map","convert","progress","normalize","firstNode","stringify","ast","params","grid","flexbox","other","module","exports"],"sources":["C:/Users/PC/Desktop/programaciÃ³n/VacunAssistIS2/Vacunassist/node_modules/autoprefixer/lib/supports.js"],"sourcesContent":["let featureQueries = require('caniuse-lite/data/features/css-featurequeries.js')\nlet { feature } = require('caniuse-lite')\nlet { parse } = require('postcss')\n\nlet Browsers = require('./browsers')\nlet brackets = require('./brackets')\nlet Value = require('./value')\nlet utils = require('./utils')\n\nlet data = feature(featureQueries)\n\nlet supported = []\nfor (let browser in data.stats) {\n  let versions = data.stats[browser]\n  for (let version in versions) {\n    let support = versions[version]\n    if (/y/.test(support)) {\n      supported.push(browser + ' ' + version)\n    }\n  }\n}\n\nclass Supports {\n  constructor(Prefixes, all) {\n    this.Prefixes = Prefixes\n    this.all = all\n  }\n\n  /**\n   * Return prefixer only with @supports supported browsers\n   */\n  prefixer() {\n    if (this.prefixerCache) {\n      return this.prefixerCache\n    }\n\n    let filtered = this.all.browsers.selected.filter(i => {\n      return supported.includes(i)\n    })\n\n    let browsers = new Browsers(\n      this.all.browsers.data,\n      filtered,\n      this.all.options\n    )\n    this.prefixerCache = new this.Prefixes(\n      this.all.data,\n      browsers,\n      this.all.options\n    )\n    return this.prefixerCache\n  }\n\n  /**\n   * Parse string into declaration property and value\n   */\n  parse(str) {\n    let parts = str.split(':')\n    let prop = parts[0]\n    let value = parts[1]\n    if (!value) value = ''\n    return [prop.trim(), value.trim()]\n  }\n\n  /**\n   * Create virtual rule to process it by prefixer\n   */\n  virtual(str) {\n    let [prop, value] = this.parse(str)\n    let rule = parse('a{}').first\n    rule.append({ prop, value, raws: { before: '' } })\n    return rule\n  }\n\n  /**\n   * Return array of Declaration with all necessary prefixes\n   */\n  prefixed(str) {\n    let rule = this.virtual(str)\n    if (this.disabled(rule.first)) {\n      return rule.nodes\n    }\n\n    let result = { warn: () => null }\n\n    let prefixer = this.prefixer().add[rule.first.prop]\n    prefixer && prefixer.process && prefixer.process(rule.first, result)\n\n    for (let decl of rule.nodes) {\n      for (let value of this.prefixer().values('add', rule.first.prop)) {\n        value.process(decl)\n      }\n      Value.save(this.all, decl)\n    }\n\n    return rule.nodes\n  }\n\n  /**\n   * Return true if brackets node is \"not\" word\n   */\n  isNot(node) {\n    return typeof node === 'string' && /not\\s*/i.test(node)\n  }\n\n  /**\n   * Return true if brackets node is \"or\" word\n   */\n  isOr(node) {\n    return typeof node === 'string' && /\\s*or\\s*/i.test(node)\n  }\n\n  /**\n   * Return true if brackets node is (prop: value)\n   */\n  isProp(node) {\n    return (\n      typeof node === 'object' &&\n      node.length === 1 &&\n      typeof node[0] === 'string'\n    )\n  }\n\n  /**\n   * Return true if prefixed property has no unprefixed\n   */\n  isHack(all, unprefixed) {\n    let check = new RegExp(`(\\\\(|\\\\s)${utils.escapeRegexp(unprefixed)}:`)\n    return !check.test(all)\n  }\n\n  /**\n   * Return true if we need to remove node\n   */\n  toRemove(str, all) {\n    let [prop, value] = this.parse(str)\n    let unprefixed = this.all.unprefixed(prop)\n\n    let cleaner = this.all.cleaner()\n\n    if (\n      cleaner.remove[prop] &&\n      cleaner.remove[prop].remove &&\n      !this.isHack(all, unprefixed)\n    ) {\n      return true\n    }\n\n    for (let checker of cleaner.values('remove', unprefixed)) {\n      if (checker.check(value)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Remove all unnecessary prefixes\n   */\n  remove(nodes, all) {\n    let i = 0\n    while (i < nodes.length) {\n      if (\n        !this.isNot(nodes[i - 1]) &&\n        this.isProp(nodes[i]) &&\n        this.isOr(nodes[i + 1])\n      ) {\n        if (this.toRemove(nodes[i][0], all)) {\n          nodes.splice(i, 2)\n          continue\n        }\n\n        i += 2\n        continue\n      }\n\n      if (typeof nodes[i] === 'object') {\n        nodes[i] = this.remove(nodes[i], all)\n      }\n\n      i += 1\n    }\n    return nodes\n  }\n\n  /**\n   * Clean brackets with one child\n   */\n  cleanBrackets(nodes) {\n    return nodes.map(i => {\n      if (typeof i !== 'object') {\n        return i\n      }\n\n      if (i.length === 1 && typeof i[0] === 'object') {\n        return this.cleanBrackets(i[0])\n      }\n\n      return this.cleanBrackets(i)\n    })\n  }\n\n  /**\n   * Add \" or \" between properties and convert it to brackets format\n   */\n  convert(progress) {\n    let result = ['']\n    for (let i of progress) {\n      result.push([`${i.prop}: ${i.value}`])\n      result.push(' or ')\n    }\n    result[result.length - 1] = ''\n    return result\n  }\n\n  /**\n   * Compress value functions into a string nodes\n   */\n  normalize(nodes) {\n    if (typeof nodes !== 'object') {\n      return nodes\n    }\n\n    nodes = nodes.filter(i => i !== '')\n\n    if (typeof nodes[0] === 'string') {\n      let firstNode = nodes[0].trim()\n\n      if (\n        firstNode.includes(':') ||\n        firstNode === 'selector' ||\n        firstNode === 'not selector'\n      ) {\n        return [brackets.stringify(nodes)]\n      }\n    }\n    return nodes.map(i => this.normalize(i))\n  }\n\n  /**\n   * Add prefixes\n   */\n  add(nodes, all) {\n    return nodes.map(i => {\n      if (this.isProp(i)) {\n        let prefixed = this.prefixed(i[0])\n        if (prefixed.length > 1) {\n          return this.convert(prefixed)\n        }\n\n        return i\n      }\n\n      if (typeof i === 'object') {\n        return this.add(i, all)\n      }\n\n      return i\n    })\n  }\n\n  /**\n   * Add prefixed declaration\n   */\n  process(rule) {\n    let ast = brackets.parse(rule.params)\n    ast = this.normalize(ast)\n    ast = this.remove(ast, rule.params)\n    ast = this.add(ast, rule.params)\n    ast = this.cleanBrackets(ast)\n    rule.params = brackets.stringify(ast)\n  }\n\n  /**\n   * Check global options\n   */\n  disabled(node) {\n    if (!this.all.options.grid) {\n      if (node.prop === 'display' && node.value.includes('grid')) {\n        return true\n      }\n      if (node.prop.includes('grid') || node.prop === 'justify-items') {\n        return true\n      }\n    }\n\n    if (this.all.options.flexbox === false) {\n      if (node.prop === 'display' && node.value.includes('flex')) {\n        return true\n      }\n      let other = ['order', 'justify-content', 'align-items', 'align-content']\n      if (node.prop.includes('flex') || other.includes(node.prop)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\nmodule.exports = Supports\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}